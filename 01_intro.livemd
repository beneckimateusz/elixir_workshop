<!-- livebook:{"persist_outputs":true} -->

# 01 // Intro

```elixir
Mix.install([
  {:kino, "~> 0.10.0"}
])
```

<!-- livebook:{"output":true} -->

```
:ok
```

## Basic Data Types

[`IEx.Helpers.i/1`](https://hexdocs.pm/iex/IEx.Helpers.html#i/1) is automatically imported in `iex`, as well as other functions from that module, so we don't need to prefix it there.

<!-- livebook:{"break_markdown":true} -->

### [Integers](https://hexdocs.pm/elixir/Integer.html)

```elixir
value = 1
IEx.Helpers.i(value)
```

<!-- livebook:{"output":true} -->

```
Term
  1
Data type
  Integer
Reference modules
  Integer
Implemented protocols
  IEx.Info, Inspect, Kino.Render, List.Chars, String.Chars
```

There's a built in support for other numeral system bases:

```elixir
value = 0b10100111001
IEx.Helpers.i(value)
```

<!-- livebook:{"output":true} -->

```
Term
  1337
Data type
  Integer
Reference modules
  Integer
Implemented protocols
  IEx.Info, Inspect, Kino.Render, List.Chars, String.Chars
```

```elixir
0o2471
```

<!-- livebook:{"output":true} -->

```
1337
```

```elixir
0x539
```

<!-- livebook:{"output":true} -->

```
1337
```

There's also a syntax-sugar convinience for writing and especially reading big numbers in code:

```elixir
1_000_000
```

<!-- livebook:{"output":true} -->

```
1000000
```

### [Floats](https://hexdocs.pm/elixir/Float.html#content)

with 64-bit double precision

```elixir
value = 3.14
IEx.Helpers.i(3.14)
```

<!-- livebook:{"output":true} -->

```
Term
  3.14
Data type
  Float
Reference modules
  Float
Implemented protocols
  IEx.Info, Inspect, Kino.Render, List.Chars, String.Chars
```

Elixir supports `e` for exponent values:

```elixir
1.0e-10
```

<!-- livebook:{"output":true} -->

```
1.0e-10
```

### Booleans

There is `true` and `false`.

Everything except `false` and `nil` is truthy.

![](images/alien_comparisons.jpg)

```elixir
true
```

<!-- livebook:{"output":true} -->

```
true
```

```elixir
false
```

<!-- livebook:{"output":true} -->

```
false
```

### [Atoms](https://hexdocs.pm/elixir/Atom.html)

Atom is a constant whose name is its value.
They are heavily used in pattern matching, a key Elixir feature, which we will learn about later.

```elixir
:appliscale
```

<!-- livebook:{"output":true} -->

```
:appliscale
```

`true` and `false` keywords are actually `:true` and `:false` atoms underneath

```elixir
true === true
```

<!-- livebook:{"output":true} -->

```
true
```

Names of modules in Elixir are also atoms.

```elixir
MyApp.MyModule
```

<!-- livebook:{"output":true} -->

```
MyApp.MyModule
```

```elixir
is_atom(MyApp.MyModule)
```

<!-- livebook:{"output":true} -->

```
true
```

```elixir
to_string(MyApp.Module)
```

<!-- livebook:{"output":true} -->

```
"Elixir.MyApp.Module"
```

If we remove the `Elixir.` prefix from the code below, it's no longer true.

```elixir
:"Elixir.MyApp.Module" == MyApp.Module
```

<!-- livebook:{"output":true} -->

```
true
```

### [Strings](https://hexdocs.pm/elixir/String.html)

UTF-8 encoded, wrapped in double quotes

```elixir
"Elixir workshop is bussin rn fr üòéüëçüèª"
```

<!-- livebook:{"output":true} -->

```
"Elixir workshop is bussin rn fr üòéüëçüèª"
```

```elixir
"ZƒÖb zupa zƒôbowa, dƒÖb zupa dƒôbowa"
```

<!-- livebook:{"output":true} -->

```
"ZƒÖb zupa zƒôbowa, dƒÖb zupa dƒôbowa"
```

```elixir
"""
All work
and no play
makes Jack
a dull boy.
"""
```

<!-- livebook:{"output":true} -->

```
"All work\nand no play\nmakes Jack\na dull boy.\n"
```

## Basic Operations

### Comparison

<!-- livebook:{"break_markdown":true} -->

Available operators are:

* `==`, `===`
* `!=`, `!===`
* `>`, `>=`
* `<`, `<=`

`===` is just more strict than `==` when it comes to **comparing ints and floats**.

```elixir
2 == 2.0
```

<!-- livebook:{"output":true} -->

```
true
```

```elixir
2 === 2.0
```

<!-- livebook:{"output":true} -->

```
false
```

Any two types can be compared and this is the ordering of types:

`number < atom < reference < function < port < pid < tuple < map < list < bitstring`

```elixir
[1, 2, 3] > :bruh
```

<!-- livebook:{"output":true} -->

```
true
```

### String Interpolation/Concatenation

```elixir
mood = "cute"
"feelin' #{mood} might delete later idk"
```

<!-- livebook:{"output":true} -->

```
"feelin' cute might delete later idk"
```

```elixir
"feelin' " <> mood <> " might delete later idk"
```

<!-- livebook:{"output":true} -->

```
"feelin' cute might delete later idk"
```

## Collections

### [Lists](https://hexdocs.pm/elixir/List.html)

Lists may include multiple types.

```elixir
list = [1337, 1.337, :pog]
IEx.Helpers.i(list)
```

<!-- livebook:{"output":true} -->

```
Term
  [1337, 1.337, :pog]
Data type
  List
Reference modules
  List
Implemented protocols
  Collectable, Enumerable, IEx.Info, Inspect, Kino.Render, List.Chars, String.Chars, Table.Reader
```

Lists are implemented as linked lists. It's typically faster to prepend than to append:

```elixir
# Prepending (fast)
["test" | list]
```

<!-- livebook:{"output":true} -->

```
["test", 1337, 1.337, :pog]
```

```elixir
# Appending (slow)
list ++ ["test"]
```

<!-- livebook:{"output":true} -->

```
[1337, 1.337, :pog, "test"]
```

üôãüèª **What is the complexity of `length(list)` in Elixir?**

<!-- livebook:{"break_markdown":true} -->

By the way, operators like `++` (list concatenation), `--` (list subtraction) are actually functions from the [`Kernel`](https://hexdocs.pm/elixir/Kernel.html#functions) module. They are always imported by default so you don't have to prefix them. However, there are some cases where you must do that and you'll get to know them later.

```elixir
Kernel.++(list, ["test"])
```

<!-- livebook:{"output":true} -->

```
[1337, 1.337, :pog, "test"]
```

#### Head/Tail

```elixir
list
```

<!-- livebook:{"output":true} -->

```
[1337, 1.337, :pog]
```

üôãüèª **What `list` are we referring to?** Why `"test"` is neither the head nor in the tail?

<!-- livebook:{"break_markdown":true} -->

![](images/head_tail.png)

```elixir
hd(list)
```

<!-- livebook:{"output":true} -->

```
1337
```

```elixir
tl(list)
```

<!-- livebook:{"output":true} -->

```
[1.337, :pog]
```

### [Tuples](https://hexdocs.pm/elixir/Tuple.html)

Similar to lists, but stored contiguously in memory.

```elixir
tuple = {1337, 1.337, :pog}
IEx.Helpers.i(tuple)
```

<!-- livebook:{"output":true} -->

```
Term
  {1337, 1.337, :pog}
Data type
  Tuple
Reference modules
  Tuple
Implemented protocols
  IEx.Info, Inspect, Kino.Render
```

Given the aforementioned fact, we know that getting the size of a tuple is faster than getting the length of a list.

**Rule of a thumb from the old times when C ruled:** _size_ stands for something fixed and _length_ stands for something variable.

[Unfortunately, Java decided to turn things around.](https://softwareengineering.stackexchange.com/questions/303909/what-is-the-difference-between-size-and-length)

```elixir
File.read("path/to/unknown/file")
```

<!-- livebook:{"output":true} -->

```
{:error, :enoent}
```

### [Keyword lists](https://hexdocs.pm/elixir/Keyword.html)

It's a special list of two-element tuples whose first element is an atom.

Keys are **ordered** and don't have to be unique.

```elixir
kl = [foo: "bar", hello: "world"]
IEx.Helpers.i(kl)
```

<!-- livebook:{"output":true} -->

```
Term
  [foo: "bar", hello: "world"]
Data type
  List
Description
  This is what is referred to as a "keyword list". A keyword list is a list
  of two-element tuples where the first element of each tuple is an atom.
Reference modules
  Keyword, List
Implemented protocols
  Collectable, Enumerable, IEx.Info, Inspect, Kino.Render, List.Chars, String.Chars, Table.Reader
```

```elixir
[{:foo, "bar"}, {:hello, "world"}] == kl
```

<!-- livebook:{"output":true} -->

```
true
```

### [Maps](https://hexdocs.pm/elixir/Map.html)

Keys can be of any type and **are not ordered**.

```elixir
map = %{:foo => "bar", "hello" => :world}
IEx.Helpers.i(map)
```

<!-- livebook:{"output":true} -->

```
Term
  %{:foo => "bar", "hello" => :world}
Data type
  Map
Reference modules
  Map
Implemented protocols
  Collectable, Enumerable, IEx.Info, Inspect, Kino.Render, Table.Reader
```

There is a special syntax for maps containing **only atom keys**:

```elixir
special_syntax_map = %{key1: "val1", key2: "val2"}
```

<!-- livebook:{"output":true} -->

```
%{key1: "val1", key2: "val2"}
```

```elixir
special_syntax_map == %{:key1 => "val1", :key2 => "val2"}
```

<!-- livebook:{"output":true} -->

```
true
```

Here's a sneak peek of using the `Map` module.

`Map.put/3` allows to put a value in the map under a key.

<!-- livebook:{"break_markdown":true} -->

‚å®Ô∏è Hands-on: create a new Elixir cell below and add a key-value pair to the `special_syntax_map` map.

<!-- livebook:{"break_markdown":true} -->

There's also a shortcut for updating **existing** keys in a map:

```elixir
%{special_syntax_map | key1: "new value"}
```

<!-- livebook:{"output":true} -->

```
%{key1: "new value", key2: "val2"}
```

It won't work for keys that don't already exist in the map:

```elixir
%{special_syntax_map | odd_key: "test"}
```

## Functions

### Anonymous function

An anonymous function **has no name**. They are frequently passed to other functions.

```elixir
sum = fn a, b -> a + b end
```

<!-- livebook:{"output":true} -->

```
#Function<41.125776118/2 in :erl_eval.expr/6>
```

```elixir
sum(7, 3)
```

<!-- livebook:{"output":true} -->

```
error: undefined function sum/2 (there is no such import)
  stuff/elixir_workshop/01_intro.livemd#cell:eesrhhsufiwb2wlvjzvymubqguz375cx:1

```

If you're invoking the anonymous function itself you must follow it with a `.`.

```elixir
sum.(7, 3)
```

<!-- livebook:{"output":true} -->

```
10
```

#### The `&` shorthand

It takes some time to get used to it. Parameters can be referred to as `&1`, `&2`, and so on, almost like in Bash, but starting from `1`.

```elixir
subtract = &(&1 - &2)
```

<!-- livebook:{"output":true} -->

```
&:erlang.-/2
```

```elixir
subtract.(5, 4)
```

<!-- livebook:{"output":true} -->

```
1
```

### Named functions

Named functions are defined **within a module** using the `def` keyword.

In simple terms, module is a collection of functions and a way to organize the code. That's all we need to know for know.

```elixir
defmodule DummyCow do
  def say() do
    """
          ________________________________________
    / There are only two hard things in        \\
    | Computer Science: cache invalidation and |
    \\ naming things.                           /
      ----------------------------------------
            \   ^__^ 
              \  (oo)\_______
                (__)\       )\/\\
                    ||----w |
                    ||     ||
    """
  end

  # short functions can be defined in one line
  def oneliner(a, b), do: a + b
end
```

<!-- livebook:{"output":true} -->

```
{:module, DummyCow, <<70, 79, 82, 49, 0, 0, 7, ...>>, {:oneliner, 2}}
```

```elixir
DummyCow.say()
```

<!-- livebook:{"output":true} -->

```
"      ________________________________________\n/ There are only two hard things in        \\\n| Computer Science: cache invalidation and |\n\\ naming things.                           /\n  ----------------------------------------\n           ^__^ \n            (oo)_______\n            (__)       )/\\\n                ||----w |\n                ||     ||\n"
```

```elixir
DummyCow.oneliner(1, 2)
```

<!-- livebook:{"output":true} -->

```
3
```

### Arity

For now, we just need to know that _arity_ is a number of input parameters that a function takes.

<!-- livebook:{"break_markdown":true} -->

### Pipe operator

Takes the result of one expression and passes it on as the first argument to the next one (like in Bash, again).

```elixir
input = "   skcor rixile     "
```

<!-- livebook:{"output":true} -->

```
"   skcor rixile     "
```

```elixir
String.split(String.upcase(String.trim(String.reverse(input))))
```

<!-- livebook:{"output":true} -->

```
["ELIXIR", "ROCKS"]
```

vs.

```elixir
input
|> String.reverse()
|> String.trim()
|> String.upcase()
|> String.split()
```

<!-- livebook:{"output":true} -->

```
["ELIXIR", "ROCKS"]
```

## Enum

```elixir
Enum.__info__(:functions)
|> Enum.map(fn {name, _arity} -> name end)
|> Enum.uniq()
|> length()

# |> dbg()
```

<!-- livebook:{"output":true} -->

```
74
```

The [Enum](https://hexdocs.pm/elixir/Enum.html) module includes --number from above-- functions for working with enumerables.

**All the collections (except Tuples) that we just learned about are enumerables**.

<!-- livebook:{"break_markdown":true} -->

### Examples

<!-- livebook:{"break_markdown":true} -->

#### [`Enum.filter/2`](https://hexdocs.pm/elixir/Enum.html#filter/2)

```elixir
Enum.filter([1, 2, 3, 4], fn x -> rem(x, 2) == 0 end)
```

<!-- livebook:{"output":true} -->

```
[2, 4]
```

```elixir
Enum.filter([1, 2, 3, 4], &(rem(&1, 2) == 0))
```

<!-- livebook:{"output":true} -->

```
[2, 4]
```

```elixir
even? = &(rem(&1, 2) == 0)
Enum.filter([1, 2, 3, 4], even?)
```

<!-- livebook:{"output":true} -->

```
[2, 4]
```

#### [`Enum.reduce/3`](https://hexdocs.pm/elixir/Enum.html#reduce/3)

```elixir
Enum.reduce([1, 2, 3], 0, fn x, acc -> acc + x end)
```

<!-- livebook:{"output":true} -->

```
6
```

```elixir
Enum.reduce([1, 2, 3], 0, &Kernel.+/2)
```

<!-- livebook:{"output":true} -->

```
6
```

## Pattern matching

A powerful part of Elixir.

Something like [Javascript destructuring assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment?retiredLocale=pl) but on steroids.

<!-- livebook:{"break_markdown":true} -->

### Match Operator

<!-- livebook:{"break_markdown":true} -->

Elixir tries to match the values on the left hand of the match operator `=` (which we call a _pattern_) with the values on the right hand. If it succeeds, it returns the right hand side.

<!-- livebook:{"break_markdown":true} -->

A variable always matches the right-side term, and it becomes bound to the value of that term.

```elixir
x = 1
```

<!-- livebook:{"output":true} -->

```
1
```

```elixir
x
```

<!-- livebook:{"output":true} -->

```
1
```

```elixir
1 = x
```

<!-- livebook:{"output":true} -->

```
1
```

```elixir
2 = x
```

#### Tuple example

```elixir
{amount, amount, amount} = {127, 127, 128}
```

```elixir
{amount, amount, amount} = {127, 127, 127}
```

<!-- livebook:{"output":true} -->

```
{127, 127, 127}
```

We use a `:calendar.local_time/0` funtion which comes from Erlang, hence it's referred to as `:calendar` and not `Calendar`, because as we remember, `Calendar` resolves to `:"Elixir.Calendar"`.

```elixir
{date, time} = :calendar.local_time()
```

<!-- livebook:{"output":true} -->

```
{{2023, 9, 12}, {8, 22, 32}}
```

```elixir
{year, month, day} = date
```

<!-- livebook:{"output":true} -->

```
{2023, 9, 12}
```

```elixir
month
```

<!-- livebook:{"output":true} -->

```
9
```

```elixir
{hour, minute, second} = time
```

<!-- livebook:{"output":true} -->

```
{8, 22, 32}
```

```elixir
second
```

<!-- livebook:{"output":true} -->

```
32
```

```elixir
{_, {hour, _, _}} = :calendar.local_time()
hour
```

<!-- livebook:{"output":true} -->

```
8
```

#### List example

Remember head and tail?

```elixir
list = [1, 2, 3]
```

<!-- livebook:{"output":true} -->

```
[1, 2, 3]
```

```elixir
[1 | _] = list
```

<!-- livebook:{"output":true} -->

```
[1, 2, 3]
```

```elixir
[_ | tail] = list
tail
```

<!-- livebook:{"output":true} -->

```
[2, 3]
```

```elixir
[] = list
```

```elixir
[_] = list
```

```elixir
[_ | _] = list
```

<!-- livebook:{"output":true} -->

```
[1, 2, 3]
```

### Pin operator

<!-- livebook:{"break_markdown":true} -->

The match operator performs assignment when the left side of the match includes a variable.

In some cases this variable rebinding behavior is undesirable. For these situations we have the pin operator: `^`.

```elixir
x = 1
x
```

<!-- livebook:{"output":true} -->

```
1
```

```elixir
x = 2
x
```

<!-- livebook:{"output":true} -->

```
2
```

```elixir
^x = 3
```

```elixir
x
```

<!-- livebook:{"output":true} -->

```
2
```

```elixir
{x, ^x} = {3, 2}
```

<!-- livebook:{"output":true} -->

```
{3, 2}
```

```elixir
x
```

<!-- livebook:{"output":true} -->

```
3
```

## Control structures

Control structures have return values, so their result can be assigned to a variable.

<!-- livebook:{"break_markdown":true} -->

### `if`

```elixir
if false do
  "not the result"
else
  "result"
end
```

<!-- livebook:{"output":true} -->

```
"result"
```

`else` is not obligatory

```elixir
if "truthy value" do
  "truthy"
end
```

<!-- livebook:{"output":true} -->

```
"truthy"
```

```elixir
if false do
  "that's not the result"
end
```

<!-- livebook:{"output":true} -->

```
nil
```

There's no `else if`/`elif` counterpart but there are other control structures that achieve a lot powered by pattern matching.

<!-- livebook:{"break_markdown":true} -->

### `case`

<!-- livebook:{"break_markdown":true} -->

Handful if it's neccessary to match against multiple patterns.

```elixir
case {:ok, "hello world"} do
  {:ok, result} -> result
  {:error} -> "nahh"
  _ -> "catch em all"
end
```

<!-- livebook:{"output":true} -->

```
"hello world"
```

```elixir
case 12 do
  {:ok, result} -> result
  {:error} -> "nahh"
  _ -> "catch em all"
end
```

<!-- livebook:{"output":true} -->

```
"catch em all"
```

The `_` variable is an important inclusion in `case/2` statements. Without it, failure to find a match will raise an error:

```elixir
case :even do
  :odd -> "odd"
end
```

## Code examples

```elixir
defmodule Recursion do
  def factorial(0), do: 1
  def factorial(n) when n > 0, do: n * factorial(n - 1)
end
```

<!-- livebook:{"output":true} -->

```
{:module, Recursion, <<70, 79, 82, 49, 0, 0, 6, ...>>, {:factorial, 1}}
```

### Recursion and multi-clause functions using pattern matching

<!-- livebook:{"break_markdown":true} -->

Multi-clause function (same arity for every clause) is just one function underneath, but visually it's splitted into multiple clauses.

```elixir
Recursion.factorial(0)
```

<!-- livebook:{"output":true} -->

```
1
```

```elixir
Recursion.factorial(5)
```

<!-- livebook:{"output":true} -->

```
120
```

```elixir
Recursion.factorial(-1)
```

### Frequencies

<!-- livebook:{"break_markdown":true} -->

üßëüèª‚Äçüè´ Explain map pattern matching and key binding.

```elixir
defmodule Example do
  def frequencies(sequence) do
    Enum.reduce(sequence, %{}, fn key, frequencies ->
      case frequencies do
        %{^key => count} -> %{frequencies | key => count + 1}
        %{} -> Map.put(frequencies, key, 1)
      end
    end)
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, Example, <<70, 79, 82, 49, 0, 0, 7, ...>>, {:frequencies, 1}}
```

```elixir
list = [1, 1, 2, 3, 2, 4, 5, 4, 4]
Example.frequencies(list)
```

<!-- livebook:{"output":true} -->

```
%{1 => 2, 2 => 2, 3 => 1, 4 => 3, 5 => 1}
```

Of course, `Enum` has it already [implemented for us](https://github.com/elixir-lang/elixir/blob/main/lib/elixir/lib/enum.ex#L1331-L1338):

```elixir
Enum.frequencies(list)
```

<!-- livebook:{"output":true} -->

```
%{1 => 2, 2 => 2, 3 => 1, 4 => 3, 5 => 1}
```
