<!-- livebook:{"persist_outputs":true} -->

# 01 // Intro

```elixir
Mix.install([
  {:kino, "~> 0.10.0"}
])
```

<!-- livebook:{"output":true} -->

```
:ok
```

## Basic Data Types

[`IEx.Helpers.i/1`](https://hexdocs.pm/iex/IEx.Helpers.html#i/1) is automatically imported in `iex`, as well as other functions from that module, so we don't need to prefix it there.

<!-- livebook:{"break_markdown":true} -->

### [Integers](https://hexdocs.pm/elixir/Integer.html)

```elixir
value = 1
IEx.Helpers.i(value)
```

<!-- livebook:{"output":true} -->

```
Term
  1
Data type
  Integer
Reference modules
  Integer
Implemented protocols
  IEx.Info, Inspect, Kino.Render, List.Chars, String.Chars
```

There's a built in support for other numeral system bases:

```elixir
value = 0b10100111001
IEx.Helpers.i(value)
```

<!-- livebook:{"output":true} -->

```
Term
  1337
Data type
  Integer
Reference modules
  Integer
Implemented protocols
  IEx.Info, Inspect, Kino.Render, List.Chars, String.Chars
```

```elixir
0o2471
```

<!-- livebook:{"output":true} -->

```
1337
```

```elixir
0x539
```

<!-- livebook:{"output":true} -->

```
1337
```

There's also a syntax-sugar convinience for writing and especially reading big numbers in code:

```elixir
1_000_000
```

<!-- livebook:{"output":true} -->

```
1000000
```

### [Floats](https://hexdocs.pm/elixir/Float.html#content)

with 64-bit double precision

```elixir
value = 3.14
IEx.Helpers.i(3.14)
```

<!-- livebook:{"output":true} -->

```
Term
  3.14
Data type
  Float
Reference modules
  Float
Implemented protocols
  IEx.Info, Inspect, Kino.Render, List.Chars, String.Chars
```

Elixir supports `e` for exponent values:

```elixir
1.0e-10
```

<!-- livebook:{"output":true} -->

```
1.0e-10
```

### Booleans

There is `true` and `false`.

Everything except `false` and `nil` is truthy.

![](images/alien_comparisons.jpg)

```elixir
true
```

<!-- livebook:{"output":true} -->

```
true
```

```elixir
false
```

<!-- livebook:{"output":true} -->

```
false
```

### [Atoms](https://hexdocs.pm/elixir/Atom.html)

Atom is a constant whose name is its value.
They are heavily used in pattern matching, a key Elixir feature, which we will learn about later.

```elixir
:appliscale
```

<!-- livebook:{"output":true} -->

```
:appliscale
```

`true` and `false` keywords are actually `:true` and `:false` atoms underneath

```elixir
true === true
```

<!-- livebook:{"output":true} -->

```
true
```

Names of modules in Elixir are also atoms.

```elixir
MyApp.MyModule
```

<!-- livebook:{"output":true} -->

```
MyApp.MyModule
```

```elixir
is_atom(MyApp.MyModule)
```

<!-- livebook:{"output":true} -->

```
true
```

```elixir
to_string(MyApp.Module)
```

<!-- livebook:{"output":true} -->

```
"Elixir.MyApp.Module"
```

If we remove the `Elixir.` prefix from the code below, it's no longer true.

```elixir
:"Elixir.MyApp.Module" == MyApp.Module
```

<!-- livebook:{"output":true} -->

```
true
```

### [Strings](https://hexdocs.pm/elixir/String.html)

UTF-8 encoded, wrapped in double quotes

```elixir
"Elixir workshop is bussin rn fr üòéüëçüèª"
```

<!-- livebook:{"output":true} -->

```
"Elixir workshop is bussin rn fr üòéüëçüèª"
```

```elixir
"ZƒÖb zupa zƒôbowa, dƒÖb zupa dƒôbowa"
```

<!-- livebook:{"output":true} -->

```
"ZƒÖb zupa zƒôbowa, dƒÖb zupa dƒôbowa"
```

```elixir
"""
All work
and no play
makes Jack
a dull boy.
"""
```

<!-- livebook:{"output":true} -->

```
"All work\nand no play\nmakes Jack\na dull boy.\n"
```

## Basic Operations

### Comparison

<!-- livebook:{"break_markdown":true} -->

Available operators are:

* `==`, `===`
* `!=`, `!===`
* `>`, `>=`
* `<`, `<=`

`===` is more strict than `==` when it comes to **comparing ints and floats**.

```elixir
2 == 2.0
```

<!-- livebook:{"output":true} -->

```
true
```

```elixir
2 === 2.0
```

<!-- livebook:{"output":true} -->

```
false
```

Any two types can be compared and this is the ordering of types:

`number < atom < reference < function < port < pid < tuple < map < list < bitstring`

```elixir
[1, 2, 3] > :bruh
```

<!-- livebook:{"output":true} -->

```
true
```

### String Interpolation/Concatenation

```elixir
mood = "cute"
"feelin' #{mood} might delete later idk"
```

<!-- livebook:{"output":true} -->

```
"feelin' cute might delete later idk"
```

```elixir
"feelin' " <> mood <> " might delete later idk"
```

<!-- livebook:{"output":true} -->

```
"feelin' cute might delete later idk"
```

## Collections

### [Lists](https://hexdocs.pm/elixir/List.html)

Lists may include multiple types.

```elixir
list = [1337, 1.337, :pog]
IEx.Helpers.i(list)
```

<!-- livebook:{"output":true} -->

```
Term
  [1337, 1.337, :pog]
Data type
  List
Reference modules
  List
Implemented protocols
  Collectable, Enumerable, IEx.Info, Inspect, Kino.Render, List.Chars, String.Chars, Table.Reader
```

Lists are implemented as linked lists. It's typically faster to prepend than to append:

```elixir
# Prepending (fast)
["test" | list]
```

<!-- livebook:{"output":true} -->

```
["test", 1337, 1.337, :pog]
```

```elixir
# Appending (slow)
list ++ ["test"]
```

<!-- livebook:{"output":true} -->

```
[1337, 1.337, :pog, "test"]
```

üôãüèª **What is the complexity of `length(list)` in Elixir?**

<!-- livebook:{"break_markdown":true} -->

By the way, operators like `++` (list concatenation), `--` (list subtraction) are actually functions from the [`Kernel`](https://hexdocs.pm/elixir/Kernel.html#functions) module. They are always imported by default so you don't have to prefix them. However, there are some cases where you must do that and you'll get to know them later.

<!-- livebook:{"break_markdown":true} -->

#### Head/Tail

<!-- livebook:{"break_markdown":true} -->

![](images/head_tail.png)

```elixir
hd(list)
```

<!-- livebook:{"output":true} -->

```
1337
```

```elixir
tl(list)
```

<!-- livebook:{"output":true} -->

```
[1.337, :pog]
```

üôãüèª **What `list` are we referring to?** Why `"test"` is neither the head nor in the tail?

<!-- livebook:{"break_markdown":true} -->

### [Tuples](https://hexdocs.pm/elixir/Tuple.html)

Similar to lists, but stored contiguously in memory.

```elixir
tuple = {1337, 1.337, :pog}
IEx.Helpers.i(tuple)
```

<!-- livebook:{"output":true} -->

```
Term
  {1337, 1.337, :pog}
Data type
  Tuple
Reference modules
  Tuple
Implemented protocols
  IEx.Info, Inspect, Kino.Render
```

Given the aforementioned fact, we know that getting the size of a tuple is faster than getting the length of a list.

**Rule of a thumb from the old times when C ruled:** _size_ stands for something fixed and _length_ stands for something variable.

[Unfortunately, Java decided to turn things around.](https://softwareengineering.stackexchange.com/questions/303909/what-is-the-difference-between-size-and-length)

```elixir
File.read("path/to/unknown/file")
```

<!-- livebook:{"output":true} -->

```
{:error, :enoent}
```

### [Keyword lists](https://hexdocs.pm/elixir/Keyword.html)

It's a special list of two-element tuples whose first element is an atom.

Keys are **ordered** and don't have to be unique.

```elixir
kl = [foo: "bar", hello: "world"]
IEx.Helpers.i(kl)
```

<!-- livebook:{"output":true} -->

```
Term
  [foo: "bar", hello: "world"]
Data type
  List
Description
  This is what is referred to as a "keyword list". A keyword list is a list
  of two-element tuples where the first element of each tuple is an atom.
Reference modules
  Keyword, List
Implemented protocols
  Collectable, Enumerable, IEx.Info, Inspect, Kino.Render, List.Chars, String.Chars, Table.Reader
```

```elixir
[{:foo, "bar"}, {:hello, "world"}] == kl
```

<!-- livebook:{"output":true} -->

```
true
```

### [Maps](https://hexdocs.pm/elixir/Map.html)

Keys can be of any type and **are not ordered**.

```elixir
map = %{:foo => "bar", "hello" => :world}
IEx.Helpers.i(map)
```

<!-- livebook:{"output":true} -->

```
Term
  %{:foo => "bar", "hello" => :world}
Data type
  Map
Reference modules
  Map
Implemented protocols
  Collectable, Enumerable, IEx.Info, Inspect, Kino.Render, Table.Reader
```

There is a special syntax for maps containing **only atom keys**:

```elixir
special_syntax_map = %{key1: "val1", key2: "val2"}
```

<!-- livebook:{"output":true} -->

```
%{key1: "val1", key2: "val2"}
```

```elixir
special_syntax_map == %{:key1 => "val1", :key2 => "val2"}
```

<!-- livebook:{"output":true} -->

```
true
```

Here's a sneak peek of using the `Map` module.

`Map.put/3` allows to put a value in the map under a key.

<!-- livebook:{"break_markdown":true} -->

‚å®Ô∏è TODO: create a new Elixir cell below and a key-value pair to the `special_syntax_map` map.

## Functions

### Anonymous function

An anonymous function **has no name**. They are frequently passed to other functions.

```elixir
sum = fn a, b -> a + b end
```

<!-- livebook:{"output":true} -->

```
#Function<41.125776118/2 in :erl_eval.expr/6>
```

```elixir
sum(7, 3)
```

<!-- livebook:{"output":true} -->

```
error: undefined function sum/2 (there is no such import)
  stuff/elixir_workshop/01_intro.livemd#cell:4c24sprar5tmoh4dxn6x6ey6nizyocmp:1

```

If you're invoking the anonymous function itself you must follow it with a `.`.

```elixir
sum.(7, 3)
```

<!-- livebook:{"output":true} -->

```
10
```

#### The `&` shorthand

It takes some time to get used to it. Parameters can be referred to as `&1`, `&2`, and so on, almost like in Bash, but starting from `1`.

```elixir
subtract = &(&1 - &2)
```

<!-- livebook:{"output":true} -->

```
&:erlang.-/2
```

```elixir
subtract.(5, 4)
```

<!-- livebook:{"output":true} -->

```
1
```

### Arity

For now, we just need to know that _arity_ is a number of input parameters that a function takes.

<!-- livebook:{"break_markdown":true} -->

### Pipe operator

Takes the result of one expression and passes it on as the first argument to the next one (like in Bash, again).

```elixir
input = "   skcor rixile     "
```

<!-- livebook:{"output":true} -->

```
"   skcor rixile     "
```

```elixir
String.split(String.upcase(String.trim(String.reverse(input))))
```

<!-- livebook:{"output":true} -->

```
["ELIXIR", "ROCKS"]
```

vs.

```elixir
input
|> String.reverse()
|> String.trim()
|> String.upcase()
|> String.split()
```

<!-- livebook:{"output":true} -->

```
["ELIXIR", "ROCKS"]
```

TODO: fit named functions + multi-clause somewhere

## Enum

```elixir
Enum.__info__(:functions)
|> Enum.map(fn {name, _arity} -> name end)
|> Enum.uniq()
|> length()

# |> dbg()
```

<!-- livebook:{"output":true} -->

```
74
```

The [Enum](https://hexdocs.pm/elixir/Enum.html) module includes --number from above-- functions for working with enumerables.

**All the collections (except Tuples) that we just learned about are enumerables**.

<!-- livebook:{"break_markdown":true} -->

### Examples

<!-- livebook:{"break_markdown":true} -->

#### [`Enum.filter/2`](https://hexdocs.pm/elixir/Enum.html#filter/2)

```elixir
Enum.filter([1, 2, 3, 4], fn x -> rem(x, 2) == 0 end)
```

<!-- livebook:{"output":true} -->

```
[2, 4]
```

#### [`Enum.reduce/3`](https://hexdocs.pm/elixir/Enum.html#reduce/3)

```elixir
Enum.reduce([1, 2, 3], 0, fn x, acc -> acc + x end)
```

<!-- livebook:{"output":true} -->

```
6
```
